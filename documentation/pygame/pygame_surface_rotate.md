[![StackOverflow](https://stackexchange.com/users/flair/7322082.png)](https://stackoverflow.com/users/5577765/rabbid76?tab=profile) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [![reply.it](../../resource/logo/Repl_it_logo_80.png) reply.it](https://repl.it/repls/folder/PyGame%20Examples)

---

# Rotate surface

Related Stack Overflow questions:

- [How do I rotate an image around its center using PyGame?](https://stackoverflow.com/questions/4183208/how-do-i-rotate-an-image-around-its-center-using-pygame/54714144#54714144)  
  ![How do I rotate an image around its center using Pygame?](https://i.stack.imgur.com/diqBY.gif)
- [How can you rotate an image around an off center pivot in PyGame](https://stackoverflow.com/questions/59909942/how-can-you-rotate-an-image-around-an-off-center-pivot-in-pygame/59909946#59909946/59909946#59909946)  
  ![How can you rotate an image around an off center pivot in PyGame](https://i.stack.imgur.com/BmG1u.gif)
- [How to rotate an image around its center while its scale is getting larger(in Pygame)](https://stackoverflow.com/questions/54462645/how-to-rotate-an-image-around-its-center-while-its-scale-is-getting-largerin-py/54713639#54713639/54713639#54713639)  
  ![How to rotate an image around its center while its scale is getting larger(in Pygame)](https://i.stack.imgur.com/NghO9.gif)

Short answer:

Store the center of the source image rectangle and update the center of the rotated image rectangle after the rotation, by the stored center position and return a tuple of the rotated image and the rectangle:

```py
def rot_center(image, angle):

    center = image.get_rect().center
    rotated_image = pygame.transform.rotate(image, angle)
    new_rect = rotated_image.get_rect(center = center)

    return rotated_image, new_rect
```

Or write a function which rotates and `.blit` the image:

```py
def blitRotateCenter(surf, image, topleft, angle):

    rotated_image = pygame.transform.rotate(image, angle)
    new_rect = rotated_image.get_rect(center = image.get_rect(topleft = topleft).center)

    surf.blit(rotated_image, new_rect.topleft)
```

Long answer:

For the following examples and explanation I'll use a simple image generated by a rendered text:

```py
font = pygame.font.SysFont('Times New Roman', 50)
text = font.render('image', False, (255, 255, 0))
image = pygame.Surface((text.get_width()+1, text.get_height()+1))
pygame.draw.rect(image, (0, 0, 255), (1, 1, *text.get_size()))
image.blit(text, (1, 1))
```

An image ([`pygame.Surface`](https://www.pygame.org/docs/ref/surface.html)) can be rotated by [`pygame.transform.rotate`](https://www.pygame.org/docs/ref/transform.html#pygame.transform.rotate).

If that is done progressively in a loop, then the image gets distorted and rapidly increases:

```py
while not done:

    # [...]

    image = pygame.transform.rotate(image, 1)
    screen.blit(image, pos)
    pygame.display.flip()
```

![rotate 1](https://i.stack.imgur.com/AXgmY.gif)

:scroll: **[Minimal example - Distortion](../../examples/surface_rotate/pygame_image_rotate_1_distort.py)**

This is cause, because the bounding rectangle of a rotated image is always greater than the bounding rectangle of the original image (except some rotations by multiples of 90 degrees).  
The image gets distort because of the multiply copies. Each rotation generates a small error (inaccuracy). The sum of the errors is growing and the images decays.

That can be fixed by keeping the original image and "blit" an image which was generated by a single rotation operation form the original image.

```py
angle = 0
while not done:

    # [...]

    rotated_image = pygame.transform.rotate(image, angle)
    angle += 1

    screen.blit(rotated_image, pos)
    pygame.display.flip()
```

![rotate 2](https://i.stack.imgur.com/vrhgt.gif)

:scroll: **[Minimal example - Rotate](../../examples/surface_rotate/pygame_image_rotate_2_rotate.py)**

Now the image seems to arbitrary change its position, because the size of the image changes by the rotation and origin is always the top left of the bounding rectangle of the image.

This can be compensated by comparing the [axis aligned bounding box](https://en.wikipedia.org/wiki/Minimum_bounding_box) of the image before the rotation and after the rotation.  
For the following math [`pygame.math.Vector2`](https://www.pygame.org/docs/ref/math.html) is used. Note in screen coordinates the y points down the screen, but the mathematical y axis points form the bottom to the top. This causes that the y axis has to be "flipped" during calculations  

Set up a list with the 4 corner points of the bounding box:

```py
w, h = image.get_size()
box = [pygame.math.Vector2(p) for p in [(0, 0), (w, 0), (w, -h), (0, -h)]]
```

Rotate the vectors to the corner points by [`pygame.math.Vector2.rotate`](https://www.pygame.org/docs/ref/math.html#pygame.math.Vector2.rotate):

```py
box_rotate = [p.rotate(angle) for p in box]
```

Get the minimum and the maximum of the rotated points:

```py
min_box = (min(box_rotate, key=lambda p: p[0])[0], min(box_rotate, key=lambda p: p[1])[1])
max_box = (max(box_rotate, key=lambda p: p[0])[0], max(box_rotate, key=lambda p: p[1])[1])
```

Calculate the "compensated" origin of the upper left point of the image by adding the minimum of the rotated box to the position. For the y coordinate `max_box[1]` is the minimum, because of the "flipping" along the y axis:

```py
origin = (pos[0] + min_box[0], pos[1] - max_box[1])

rotated_image = pygame.transform.rotate(image, angle)
screen.blit(rotated_image, origin)
```

![rotate 3](https://i.stack.imgur.com/IKZ6a.gif)

:scroll: **[Minimal example - Rotate around (0, 0)](../../examples/surface_rotate/pygame_image_rotate_3__0_0.py)**

It is even possible to define a pivot on the original image. The "translation" of the pivot in relation to the upper left of the image has to be calculated and the "blit" position of the image has to be displaced by the translation.

Define a pivot e.g. in the center of the image:

```py
pivot = pygame.math.Vector2(w/2, -h/2)
```

Calculate the translation of the rotated pivot:

```py
pivot_rotate = pivot.rotate(angle)
pivot_move   = pivot_rotate - pivot
```

Finally calculate the origin of the rotated image:

```py
origin = (pos[0] + min_box[0] - pivot_move[0], pos[1] - max_box[1] + pivot_move[1])

rotated_image = pygame.transform.rotate(image, angle)
screen.blit(rotated_image, origin)
```

In the following example program, the function `blitRotate(surf, image, pos, originPos, angle)` does all the above steps and "blit" a rotated image to a surface.  

- `surf` is the target Surface

- `image` is the Surface which has to be rotated and `blit`

- `pos` is the position of the pivot on the target Surface `surf` (relative to the top left of `surf`)

- `originPos` is position of the pivot on the `image` Surface (relative to the top left of `image`)

- `angle` is the angle of rotation in degrees

![rotate 4](https://i.stack.imgur.com/qnDPP.gif)

:scroll: **[Minimal example - Rotate around pivot](../../examples/surface_rotate/pygame_image_rotate_4_pivot.py)**

:scroll: **[Minimal example - Rotate around pivot function](../../examples/surface_rotate/pygame_image_rotate_5_pivot_function.py)**

<kbd>[![](https://i.stack.imgur.com/5jD0C.png) repl.it/@Rabbid76/PyGame-RotateAroundPivot](https://repl.it/@Rabbid76/PyGame-RotateAroundPivot#main.py)</kbd>

![roatate and scale](https://i.stack.imgur.com/yLxBi.gif)

:scroll: **[Minimal example - Rotate around pivot and scale](../../examples/surface_rotate/pygame_image_rotate_4_scale.py)**

:scroll: **[Minimal example - Rotate around pivot and scale function](../../examples/surface_rotate/pygame_image_rotate_5_scale_function.py)**

<kbd>[![](https://i.stack.imgur.com/5jD0C.png) repl.it/@Rabbid76/PyGame-RotateAroundPivotAndZoom](https://repl.it/@Rabbid76/PyGame-RotateAroundPivotAndZoom#main.py)</kbd>

First the position of the pivot on the `Surface` has to be defined:

```py
image = pygame.image.load("boomerang64.png") # 64x64 surface
pivot = (48, 21)                             # position of the pivot on the image
```

When an image is rotated, then its size increase. We have to compare the [axis aligned bounding box](https://en.wikipedia.org/wiki/Minimum_bounding_box) of the image before the rotation and after the rotation.  
For the following math [`pygame.math.Vector2`](https://www.pygame.org/docs/ref/math.html) is used. Note in screen coordinates the y points down the screen, but the mathematical y axis points form the bottom to the top. This causes that the y axis has to be "flipped" during calculations  

Set up a list with the 4 corner points of the bounding box and rotate the vectors to the corner points by [`pygame.math.Vector2.rotate`](https://www.pygame.org/docs/ref/math.html#pygame.math.Vector2.rotate). Finally find the minimum of the rotated box. Since the y axis in pygame points downwards, this has to be compensated by finding the maximum of the rotated inverted height ("*max(rotate(-h))*"):

```py
w, h = image.get_size()
box = [pygame.math.Vector2(p) for p in [(0, 0), (w, 0), (w, -h), (0, -h)]]
box_rotate = [p.rotate(angle) for p in box]
min_x, min_y = min(box_rotate, key=lambda p: p[0])[0], max(box_rotate, key=lambda p: p[1])[1]
```

The computation of `min_x` and `min_y` can be improved by directly computing the x and y component of the rotated vectors by [trigonometric](https://en.wikipedia.org/wiki/Trigonometry) functions:

```py
w, h         = image.get_size()
sin_a, cos_a = math.sin(math.radians(angle)), math.cos(math.radians(angle))
min_x, min_y = min([0, sin_a*h, cos_a*w, sin_a*h + cos_a*w]), max([0, sin_a*w, -cos_a*h, sin_a*w - cos_a*h])
```

Calculate the "compensated" origin of the upper left point of the image by adding the minimum of the rotated box to the position in relation to the pivot on the image:

```py
origin = (pos[0] - originPos[0] + min_x - pivot_move[0], pos[1] - originPos[1] - min_y + pivot_move[1])
rotated_image = pygame.transform.rotate(image, angle)
screen.blit(rotated_image, origin)
```

In the following example program, the function `blitRotate(surf, image, pos, originPos, angle)` does all the above steps and [`blit`](https://www.pygame.org/docs/ref/surface.html#pygame.Surface.blit) a rotated image to the Surface which is associated to the display:  

- `surf` is the target Surface
- `image` is the Surface which has to be rotated and `blit`
- `pos` is the position of the pivot on the target Surface `surf` (relative to the top left of `surf`)
- `originPos` is position of the pivot on the `image` Surface (relative to the top left of `image`)
- `angle` is the angle of rotation in degrees

![rotate](https://i.stack.imgur.com/BmG1u.gif)

:scroll: **[Minimal example - Rotate around off center pivot](../../examples/surface_rotate/pygame_image_rotate_pivot_boomerang.py)**

The same algorithm can be used for a [Sprite](https://www.pygame.org/docs/ref/sprite.html#pygame.sprite.Sprite), too.  
In that case the position (`self.pos`), pivot (`self.pivot`) and angle (`self.angle`) are instance attributes of the class.
In the `update` method the `self.rect` and `self.image` attributes are computed. e.g:

:scroll: **[Minimal example - Rotate Sprite around off center pivot](../../examples/surface_rotate/pygame_sprite_rotate_pivot_boomerang.py)**
